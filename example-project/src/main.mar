use std::print

// Hosts don't HAVE to call this function but the default CLI tool uses this
// as the entry point.
fn main() {
    print("hello world"); // semi-colons are mandatory

    // ------  the basics  -------
    // declaring a variable
    var foo = 50;
    
    // a variable is always mutable
    foo = 30;


    // basic types
    var integer : int = 50; // type hints are optional
    var num : float = 12.5;
    var yes = true;
    var text = "hello world";

    // and print can print all of them
    print(integer);
    print(num);
    print(yes);
    print(text);

    // defining a struct
    struct Foo {
        value: int,
    }


    // adding functions to a struct
    impl Foo {
        fn new(): Foo {
            // creating a struct
            Foo {
                value: 10,
            }
        }


        // or, if the function takes in `self` as a parameter it'll be a method
        fn print_value(self) {
            print(self.value)
        }


        // or it can take more parameters
        // and even return values
        fn add(self, num: int): int {
            self.value + num
            // optionally, you can also go
            // return self.value + num
            // but if the last expression in a block doesn't have a semicolon
            // following it, it is automatically assumed to be returned
        }
    }


    // however, when changing the type of a variable
    // you need to declare it again
    var foo = Foo::new();
    foo.print_value();

    // then you can modify each field individually
    foo.value = 80;

    // or re-assign it as usual
    foo = Foo { value: 400 };


    // defining an enum
    enum Value {
        // enum variants can store data types
        Left: int,
        // even custom types!
        Middle: Foo,
        // or they can just be unit
        Right,
    }

    // when using one, just call the function with the variant's name
    // if it's a unit enum, you don't need to pass in any arguments
    var value = Value::Right();

    // however, if the variant carries any additional data
    // you will need to pass it in when creating
    value = Value::Left(50);

    // you can access enum variants with the same syntax as accessing
    // a field
    var data = value.Left;

    // however, the type of `data` will be an Option<int>
    // which you can unwrap with `!` or try with `?`
    //
    // unwrapping will crash the program if it's none and 
    // trying will return none from the function if the value is none
    var inner_data = data!;

    // you can also assign to this field
    value.Left! = 50;

    // and even access it's fields
    value = Value::Middle(Foo { value: 40 });
    value.Middle!.value = 20;


    // -------- the loops -------- 

    var i = 0;
    while i < 10 { // loops while the condition is false
        print(i);
        i += 1; //
    }


    var n = 10;
    loop { // this one loops forever
        n -= 1;

        // which means we might want to terminate it manually
        if n == 0 {
            break;
        }
    }


    var range = 25..30; // a range is an iterator, which we will get to later
    for i in range { // a loop that iterates over an iterator
        print(i)
    }

    // speaking of iterators
    // ------ iterators ------
    var open_range = 0..5; // this is an open range iterator. meaning it will
                           // result in [0, 1, 2, 3, 4]
    var closed_range = 0..=5; // this is a closed range iterator. meaning it will
                              // result in [0, 1, 2, 3, 4, 5]

    // you can define your own iterators
    struct CustomIterator {
        counter: int
    }

    impl CustomIterator {
        // using the __next__ function
        // it must take in 1 argument, self; and return an Option<T>
        fn __next__(self): Option<int> {
            self.counter += 1;
            some(self.counter - 1)
        }
    }


    // and then you can create it like any other struct
    var counter = CustomIterator {
        counter: 0,
    };


    for i in counter {
        print(i);
        // we can "skip" an iterator in any loop kind by doing
        if i <= 10 {
            continue;
        }

        // which means the rest of the code won't run while i is less than 10

        // since our custom iterator never returns none, this loop will
        // go on forever. unless we break out of it of course
        if i % 2 == 0 {
            break;
        }
    }
}
